%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
\section{ECDSA One-Time VES Scheme}
\label{ecdsa-ot-ves-section}

\newcommand{\Pdleq}{\pcalgostyle{P}_{\textsf{DLEQ}}}
\newcommand{\Vdleq}{\pcalgostyle{V}_{\textsf{DLEQ}}}

Moreno-Sanchez et al.\ developed an ECDSA adaptor signature scheme compatible with Bitcoin signatures today\cite{ecdsa-scriptless-scripts}.
It has been applied to achieve a payment channel construction with better privacy in \cite{cryptoeprint:2018:472} and an efficient tumbler in \cite{cryptoeprint:2019:589}.
The original proposal is built upon the two-party ECDSA protocol from \cite{Lindell2pECDSA}.
In Figure~\ref{fig:ecdsa-adaptor} we distill it into a single signer scheme which avoids all the complexities that come with two-party ECDSA protocols.

The construction works in a similar way to the Schnorr scheme: the public randomness $R$ is mutated independently of its private counterpart $r$ to include the encryption key $Y$.
This offsets the resulting signature by the same factor.
Unfortunately, due to the non-linear structure of ECDSA it needs a non-interactive zero knowledge proof of discrete logarithm equality so the verifier can confirm that $s$ is offset by the correct amount.
we denote the proof generation and verification algorithms as follows $(\Pdleq,\Vdleq)$.
Formally, When invoked as $\Pdleq((g, A),(h,B),w)$, it generates a proof of membership of the language:

\newcommand{\DLEQ}{\textsf{DLEQ}\xspace}
\[ L_{\DLEQ} = \{ (g, h, A, B) \in \G^4 \mid  \exists w \in \ZZ_q : A = g^w \land B = h^w \} \]

Practically this proof can be instantiated with the Fiat-Shamir transform applied to the standard Sigma protocol for the relation.

\newcommand{\Rx}{R_{\mathtt{x}}}
\newcommand{\hatRx}{\hat{R}_\mathtt{x}}
\newcommand{\xcoord}{f}

\begin{figure}[h]
    \centering
    \begin{mdframed}
    \begin{pchstack}[center]
    \procedure{$\KeyGen/\EncGen$}{
        x \sample \ZZ_q; X \gets g^{x} \\
        sk := (x,X); pk := X \\
        \pcreturn (sk,pk)
    }
    \pchspace

    \procedure{$\Sign(\skSign, m)$}{
        (x,X) := \skSign; \\
        r \sample \ZZ_q; R \gets g^r \\
        \Rx \gets \xcoord(R) \\
        s \gets r^{-1}(H(m) + \Rx{}x)\\
        \pcreturn \sigma := (\Rx,s) \\
    }

    \procedure{$\Verify(\pkSign,m,\sigma)$}{
        X := \pkSign; (\Rx,s) := \sigma \\
        R' \gets (g^{H(m)}X^{\Rx})^{s^{-1}} \\
        \pcreturn \xcoord(R') = \Rx \\
    }
    \pchspace
    \procedure{$\EncSign(\skSign,\pkEnc, m)$}{%
        (x,X) := \skSign; Y := \pkEnc  \\
        r \sample \ZZ_q; \hat{R} \gets{} g^r; R \gets Y^{r} \\
        \pi \sample \pcalgostyle{P}_{\DLEQ}((g, \hat{R}), (Y, R),r) \\
        \Rx \gets \xcoord(R) \\
        \hat{s} \gets r^{-1}(H(m) + \Rx{}x)\\
        \pcreturn \hat{\sigma} := (R, \hat{R},\hat{s}, \pi) \\
    }
    \end{pchstack}
    \begin{pchstack}[center]

    \procedure{$\EncVer(\pkSign,\pkEnc, m, \hatsigma)$}{%
        X := \pkSign;  Y := \pkEnc \\
        (R, \hat{R},\hat{s}, \pi) := \hatsigma \\
        \pcalgostyle{V}_{\DLEQ}((g, \hat{R}), (Y, R)), \pi) \stackrel{?}{=} 1\\
        \Rx \gets \xcoord(R) \\
        \pcreturn \hat{R} = (g^{H(m)}X^{\Rx})^{\hat{s}^{-1}} \\
    }
    \pchspace
    \procedure{$\DecSig(\skEnc,\hatsigma)$}{
        (R, \hat{R},\hat{s}, \pi) := \hatsigma \\
        (y, Y) := \skEnc \\
        s \gets \hat{s}y^{-1} \\
        \pcreturn \sigma := (\xcoord(R),s)
    }
    \pchspace
    \procedure{$\RecKey(\pkEnc, \hatsigma)$}{
        (R, \hat{R},\hat{s}, \pi) := \hatsigma \\
        Y := \pkEnc \\
        \pcreturn \rec := (Y, \hat{s})
    }
    \pchspace
    \procedure{$\Rec(\sigma, \rec)$}{
        (\Rx,s) := \sigma; (Y, \hat{s}) := \rec \\
        \tilde{y} \gets  s^{-1}\hat{s} \\
        y := \left\{\begin{array}{l}
                \tilde{y}  \hspace{1em} \pcif g^{\tilde{y}} = Y \pclb
                -\tilde{y} \hspace{0.33em} \pcif g^{\tilde{y}} = Y^{-1} \pclb
                \bot \hspace{1em} \textbf{otherwise}
                \end{array}
             \right. \\
        \pcreturn y
    }
    \end{pchstack}
    \end{mdframed}
    \caption{The algorithms of the ECDSA one-time VES scheme. $f: \G \rightarrow \ZZ_q$ converts a an elliptic curve point to its x-coordinate mod $q$. $H$ is a hash function.}
    \label{fig:ecdsa-adaptor}
\end{figure}

We now prove the scheme is a secure one-time VES by showing it meets our requirements of validity, recoverability and $\EUFCMAVES$.
In the latter case, the proof is not straightforward because we must account for a weakness in the scheme.
First we prove validity and recoverability.

\begin{lemma}
The ECDSA one-time VES is valid and unconditionally recoverable.
\end{lemma}
\begin{proof}
If $\EncVer(X,Y,m,(R, \hat{R},\hat{s}, \pi)) = 1$ then $\hat{R} = (g^{H(m)}X^{\Rx})^{\hat{s}^{-1}}$ and $\hat{R}^y = R$ if $\pi$ is sound. Which means $\hat{R}^{y} = R = (g^{H(m)}X^{\Rx})^{\hat{s}^{-1}y}$. Therefore $\DecSig$ produces a valid signature $\sigma := (R, \hat{s}y^{-1})$ whenever $\hatsigma$ is valid except with the negligible probability that $\pi$ is unsound. If $\sigma$ is valid then $\Rec$ will always recover $\tilde{y} \gets s^{-1}\hat{s} = (\hat{s}y^{-1})^{-1}\hat{s}$, which is either equal to $y$ or $-y$ (due to $\Verify$ only checking the x-coordinate of $R$).
\end{proof}


\subsection{ECDSA $\EUFCMAVES$ security}

The ECDSA one-time VES is flawed with respect to its $\EUFCMAVES$ security. Each valid ciphertext surreptitiously leaks the Diffie-Hellman key between the public signing key and the encryption key i.e.\ allows the receiver to compute $X^y = Y^x$.
At a high level, the problem arises because the value $s$ in the signature is computed through the product of $r^{-1}$ and $x$ and then $\pi$ reveals the product of $Y$ and $r$ and $R$.
The adversary can then cancel out $r$ from the picture and is left with $Y^x$.

\begin{lemma}
  \label{key-leak}
  Let $(R, \hat{R},\hat{s}, \pi)$ be a ECDSA one-time VES ciphertext encrypted by $Y$ and assume that $\pi$ is a sound proof that $\CDH(\hat{R},Y) = R$.
  If $\EncVer(X,Y,m,(R, \hat{R},\hat{s}, \pi)) = 1$, for some message $m$ and encryption key $Y$, then $\CDH(X,Y) = (R^{\hat{s}}Y^{-H(m)})^{\Rx^{-1}}$.
\end{lemma}
\begin{proof}
  Since $\hat{s} = r^{-1}(H(m) + \Rx{}x)$ and $R = Y^r$ we can compute $Y^x$ as follows:
  \begin{align*}
    R^{\hat{s}} & = Y^{H(m) + \Rx{}x} &  \\
    R^{\hat{s}}Y^{-H(m)} & =  Y^{\Rx{}x} \\
    (R^{\hat{s}}Y^{-H(m)})^{\Rx^{-1}} & = Y^{x}
  \end{align*}
\end{proof}


\newcommand{\SDH}{\textsf{SDH}}
\newcommand{\DLSDH}{\DLOG_{\OSDH}}
\newcommand{\QDLSDH}{\text{-}\DLSDH}
\newcommand{\OSDH}{\mathcal{O}_{\SDH}}

This clearly violates the spirit of $\EUFCMAVES$ which is that nothing useful should be learned from the ciphertext other than the signature (if it can be decrypted).
To demonstrate our formal definitions do stay faithful to this idea we show there is no $\EUFCMAVES$ reduction for it

\begin{lemma}
  There is no key-preserving reduction from $\DLOG$ to the $\EUFCMAVES$ security of the ECDSA one-time VES if the $\CDH$ problem is hard.
\end{lemma}
\begin{proof}[Proof Sketch]
  Observe that any key preserving $\DLOG$ reduction must simulate the encryption oracle $E$ without the secret key $x$.
  It is not enough for this simulator to just return two random group elements $(\hat{R}, R)$ and simulate the proof $\pi$ to make them appear valid with respect to a query for an encryption under $Y$.
  We can easily catch this behaviour by querying the simulator on key $Y'$ such that we know the secret key $y'$ and checking that $\hat{R}^{y'} = R$.
  Since the simulator must return valid ciphertexts and from valid ciphertexts we can extract a Diffie-Hellman key (as shown in Lemma~\ref{key-leak}) the simulator must not exist if $\CDH$ problem is hard.
  If no simulator exists then no key-preserving reduction can exist.
\end{proof}

We now attempt to salvage the ECDSA one-time VES by isolating the security impact of the flaw.
Our approach is to show that the Diffie-Hellman key is the only extra thing that can be learned from the ciphertext.
Existing protocols that use ECDSA adaptor signatures sidestep this issue in their simulation based proofs by making any receiver of the ciphertext prove knowledge of the decryption key.
Obviously, if they already know the decryption key $y$ then they can compute $X^y = Y^x$ without help from the signer.
We seek to capture security without proofs of knowledge since it may not always be practical to provide such a proofs and it complicates the application of the scheme.
Instead, we suggest that in security proofs whenever adversary learns a ECDSA encrypted signature for a signing key $X$ and encryption key $Y$ the proof environment should leak $Y^x$ to them.

To make our case that Diffie-Hellman key is the only thing that can be learned from a ciphertext we will artificially prove $\EUFCMAVES$ security in a model where the reduction is able to request Diffie-Hellman keys for the signing key.
Since the reduction is able to perfectly simulate ECDSA encrypted signatures with access to this oracle this must be the only thing that can be learned from them.
Formally, instead of showing a reduction from $\DLOG$ we reduce from the $u\QDLSDH$ which we define as follows:

\begin{definition}[Discrete logarithm with static Diffie-Hellman oracle problem]
  An algorithm $\adv$ solves the $u\QDLSDH$ problem in a group $\G$ if the following experiment outputs 1 and $\adv$ makes $u$ or less queries to $\OSDH$.
  \begin{center}
    \fbox{
      \begin{pchstack}
      \procedure{$\DLSDH$}{
        x \sample \ZZ_q; X \gets g^x \\
        x^* \sample \adv^{\OSDH}(X) \\
        \pcreturn  x^* \stackrel{?}{=} x
      }
      \pchspace
      \procedure{$\OSDH(Y)$}{
        \pcreturn Y^x
      }
      \end{pchstack}
    }
  \end{center}
\end{definition}

Changing the problem we reduce from comes with a cost.

$u\QDLSDH$ is not as hard as ordinary $\DLOG$ for some very subtle and surprising reasons.
Brown et al.\cite{SDHP} show it is possible to use $\OSDH$ to assist in computing the discrete logarithm of the static key (in our case the public signing key).
The attack works by querying $\OSDH$ with the static key itself and thereby learning non-linear functions of the static secret key \emph{in the exponent} e.g. a query for the static key $X = g^x$ returns $g^{x^2}$ and then querying with that result returns $g^{x^3}$ and so on.
Of course, in our setting the adversary will never be able to decrypt a signature encrypted with $Y = X$ but they would nevertheless be able to extract $g^{x^2}$ from it.
Since the likely only application of this scheme will be to Bitcoin we provide concrete computational estimates on the difficulty of $u\QDLSDH$ in Bitcoin's secp256k1 group in Appendix~\ref{secp-qdlsdh}.
In practice it appears that $u\QDLSDH$ is still sufficiently hard even for very large values of $u$ (which is in our case, the number of encrypted signatures requested and received).

We now proceed to prove $\EUFCMAVES$ security from the hardness of $u\QDLSDH$.
As in the case of our Schnorr proof we use an existing $\EUFCMA$ reduction as our starting point and apply simulator substitution to arrive at $\EUFCMAVES$ reduction.
The work of Fersch et al.\cite{ecdsa-eufcma} meticulously captures the $\EUFCMA$ security of ECDSA in a \emph{bijective random oracle model} by showing a reduction from the $\DLOG$ to the $\EUFKO$ security of ECDSA which is then in-turn reduced to $\EUFCMA$ security.
Their reduction also shows the security of ECDSA relies on particular properties of the message hash function $H$.
We focus on the discrete logarithm breaking reduction but the bounds in terms of the hash function properties are implicitly included in $\bound_e$.

In the ECDSA bijective random oracle model, the conversation function $f$ which converts an elliptic curve point $R$ to its modulo $q$ reduced x-coordinate $\Rx$ is modelled as a bijective random oracle and signatures are simulated by programming it.
We provide more details of the original proof of Fersh et al.\ and prove the following theorem in Appendix~\ref{proof-ecdsa-eufcma}.

\begin{theorem}
  Let the $\DLOG$ problem be $(\tau, \e)$-hard and the $u\QDLSDH$ problem be $(\tau_{\sdh},\e_{\sdh})$-hard.
  Let $\R$ be the reduction from $\DLOG$ to the $\EUFCMA$ security of the ECDSA signature scheme in the bijective random oracle model with signature simualtor $\Sim_S$ (as in Appendix~\ref{proof-ecdsa-eufcma}).
  If $\R$ shows that the ECDSA signature scheme is at least $(\tau',\e',Q_S,Q_{\Pi})$-$\EUFCMA$ secure then the ECDSA one-time VES is at least $(\tau'',\e'',Q_E,Q_{\Pi})$-$\EUFCMAVES$ secure where
  \begin{align*}
    Q_E =  Q_S = u &&& \\
    \e'   =    \bound_\e(\e, Q_S, Q_{\Pi})  & & & \e''  = \bound_\e(\e_{\sdh}, Q_E, Q_{\Pi}) \\
    \tau' =  \bound_\tau(\tau,Q_S, Q_{\Pi})  & & & \tau'' = \bound_\tau(\tau_{\sdh},Q_E, Q_{\Pi}) -  2et_{\G^*}
  \end{align*}

  \hfill \break and $t_{\G^*}$ is the time for a scalar multiplication in $\G$ and $e$ is the number of times $\R$ executes $\Sim_S$.
\end{theorem}

The reduction only needs to query $\OSDH$ once for each query the forger makes to $E$ (i.e. $u = Q_E$) which demonstrates what we set out to prove: from each ciphertext the Diffie-Hellman key can be learned and nothing else.

We conclude with two remarks that should provide more confidence in the application of the scheme.
Firstly, the only practical way to use the ECDSA one-time VES is with \emph{pay-to-script-hash} type outputs which commit to script based spending rules with a 160-bit hash and thus only provide 80 bits of collision resistance.
It is possible to avoid relying on the collision resistance of the hash by executing a commitment round first before revealing the values that go into the script but this is rarely done in practice.
Secondly, The work of Boneh and Boyen \cite{BBSig} shows no generic algorithm can improve upon the complexity of the algorithm described in Appendix~\ref{secp-qdlsdh}.
Specifically, they prove a lower time bound of $\Omega(\sqrt{q/u})$  where $u < \sqrt[3]{q}$ and $q$ is the order of the group for any generic group model adversary against the \emph{Strong Diffie-Hellan} problem which implies the same lower bound for $u\QDLSDH$.
