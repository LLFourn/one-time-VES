\documentclass[fullpage]{article}

	\addtolength{\oddsidemargin}{-.875in}
	\addtolength{\evensidemargin}{-.875in}
	\addtolength{\textwidth}{1.75in}

	\addtolength{\topmargin}{-.875in}
	\addtolength{\textheight}{1.75in}


\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amsthm}
\usepackage{placeins}

\makeatletter
\def\th@plain{%
  \thm@notefont{}% same as heading font
  \itshape % body font
}
\def\th@definition{%
  \thm@notefont{}% same as heading font
  \normalfont % body font
}
\makeatother

\usepackage{hyperref}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{mdframed}
\usepackage{extarrows}
\usepackage{caption}
\usepackage{xspace}
\usepackage{graphicx}
\usepackage{fixltx2e}
\usepackage[n,advantage,operators,sets,adversary,landau,probability,notions,logic,ff, mm, primitives,events,complexity,asymptotics,keys]{cryptocode}
\captionsetup[figure]{labelfont={bf},name={Fig.},labelsep=period}

\newtheorem{claim}{Claim}[section]
\newtheorem{conjecture}{Conjecture}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem{theorem}{Theorem}[section]
\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{remark}{Remark}

\def\SPSB#1#2{\rlap{\textsuperscript{#1}}\SB{#2}}
\def\SP#1{\textsuperscript{#1}}
\def\SB#1{\textsubscript{#1}}

\newcommand{\EUFCMA}{\textsf{EUF-CMA}\xspace}
\newcommand{\EUFCMAVES}{\textsf{EUF-CMA}[\textsf{VES}]\xspace}
\newcommand{\EUFCMAVESot}{\textsf{EUF-CMA}[\textsf{VES}\textsubscript{ot}]\xspace}
\newcommand\getsdollar{\mathrel{{\leftarrow}\vcenter{\hbox{\tiny\rmfamily\upshape\$}}}}
\newcommand{\SE}{SE}
\newcommand{\otVES}{\textsf{VES}\textsubscript{ot}}
\newcommand{\OPCHECKMULTISIG}{\texttt{OP\_CHECKMULTISIG}\xspace}
\newcommand{\Dec}{\textsf{Dec}}


\newcommand{\Enc}{\textsf{Enc}}
\newcommand{\EncGen}{\textsf{EncGen}}
\newcommand{\EncSign}{\textsf{EncSign}}
\newcommand{\EncVer}{\textsf{EncVrfy}}

\newcommand{\DecSig}{\textsf{DecSig}}
\newcommand{\KeyGen}{\textsf{Gen}}
\newcommand{\Sign}{\textsf{Sign}}
\newcommand{\Verify}{\textsf{Vrfy}}
\newcommand{\Rec}{\textsf{Rec}}
\newcommand{\RecKey}{\textsf{RecKey}}
\newcommand{\rec}{\delta}
\newcommand{\VESALG}{\EncGen, \EncSign, \EncVer, \DecSig}
\newcommand{\SIGNALG}{\KeyGen, \Sign, \Verify}
\newcommand{\ENCALG}{\EncGen, \Enc, \Dec}

\newcommand{\skSign}{sk_S}

\newcommand{\pkSign}{pk_S}
\newcommand{\kSign}{(\skSign,\pkSign)}
\newcommand{\skEnc}{sk_E}
\newcommand{\pkEnc}{pk_E}
\newcommand{\kEnc}{(\skEnc, \pkEnc)}
\newcommand{\F}{\mathcal{F}}
\newcommand{\hatsigma}{\hat{\sigma}}
\newcommand{\hatSigma}{\hat{\Sigma}}
\newcommand{\FullEncVer}{\EncVer(\pkSign, \pkEnc, m, \hatsigma)}
\newcommand{\FullVer}{\Verify(\pkSign,m,\sigma)}
\newcommand{\R}{\mathcal{R}}
\newcommand{\RDL}{\mathcal{R}_{\DLOG}}
\newcommand{\hatR}{\hat{\mathcal{R}}}
\newcommand{\hardproblem}{\mathcal{H}}
\newcommand{\G}{\mathbb{G}}
\newcommand{\DLOG}{\textsf{DL}\xspace}
\newcommand{\Setup}{\textsf{Setup}}


\begin{document}

\title{One-Time Verifiably Encrypted Signatures \\ A.K.A. Adaptor Signatures}
\author{Lloyd Fournier\footnote{\texttt{lloyd.fourn@gmail.com}}}
\date{October 2019}

\maketitle

\begin{abstract}
  On Bitcoin-like ledgers, smart contract functionality can be realised without using the ledger's native smart contract language through the ``adaptor signature'' technique\cite{poelstra-adaptor}. An adaptor signature is a kind of partial signature that, if completed, will reveal valuable information to the signer. In this work, we conduct the first formal analysis of the adaptor signature as an isolated primitive. We find that it offers similar functionality to the already well established concept of \emph{verifiably encrypted signatures} (VES) with one notable difference: the decryption key can be recovered from the ciphertext and the decrypted signature. To capture this property, we formally introduce the notion of \emph{one-time verifiably encrypted signatures}. To properly define their security in the Bitcoin layer-2 setting we revisit the original VES definitions and modify them to remove the ingrained assumption of a trusted third party.

  After the extending our VES definitions to the one-time VES, we attempt to prove that the existing Schnorr and ECDSA adaptor signature schemes satisfy them. In the case of Schnorr, we succeed unconditionally but our definitions expose a (non-fatal) flaw in the ECDSA scheme. Nevertheless, we show how to use the ECDSA scheme to realise functionality in Bitcoin that was previously thought to be out of reach without Schnorr signatures or complex two-party ECDSA protocols.
\end{abstract}


% CDH problem?

% VERIFIABLY ENCRYPTED SIGNATURES

\include{ves}
\include{one-time-ves}
\include{schnorr}
\include{ecdsa}

\section{Semi-Scriptless Protocols}
\label{semi-scriptless}

\newcommand{\TxFund}{\texttt{Tx}_{\textsf{fund}}}
\newcommand{\TxRefund}{\texttt{Tx}_{\textsf{refund}}}
\newcommand{\TxRedeem}{\texttt{Tx}_{\textsf{redeem}}}
\newcommand{\TxInput}{\texttt{Tx}_{\textsf{input}}}
\newcommand{\addrRedeem}{addr_{B}}
\newcommand{\addrRefund}{addr_{A}}
\newcommand{\TxGen}{\textsf{Tx}}
\newcommand{\refundSig}{\sigma_{\textsf{refund}}}
\newcommand{\redeemSig}{\sigma_{\textsf{redeem}}}
\newcommand{\redeemEncSig}{\hatsigma_{\textsf{redeem}}}

The essential function of a smart contract on a Bitcoin-like ledger is to lock coins in an output such that they can only be spent to certain parties under certain conditions. With a smart contract language like Bitcoin script, the conditions can be expressed in the language and enforced by the ledger's transaction validation rules. In the scriptless model, we can only constrain spending through time-locks and by setting a public key, for which the spender must provide a signature. Clearly in order to stop one party from arbitrarily spending the coins the corresponding private key cannot be exclusively known to one party. Thus we require the parties have a joint ownership of the public key and cooperatively use a multi-signature protocol to sign transactions spending from the joint output. Multi-signature protocols exist for ECDSA\cite{Lindell2pECDSA,hash-proof-ecdsa}, Schnorr\cite{musig}, BLS\cite{compact-blockchains-bls} and most prominent signature schemes.

To realise most of the scriptless protocols from Section~\ref{exisitng-protocols}, the multi-signature scheme also needs to admit a two-party one-time VES encrypted signing protocol to emulate $\EncSign$ on a joint signing key. It is relatively simple to build this on top of a Schnorr multi-signature scheme, but since Schnorr signatures have not been included in the Bitcoin protocol yet, this tool is out of reach for now. Both the two-party ECDSA schemes in \cite{Lindell2pECDSA,hash-proof-ecdsa} admit a two-party $\EncSign$ protocol as described in \cite{ecdsa-scriptless-scripts}. Unfortunately, these schemes are complex and rely additional exotic computational hardness assumptions. As a result, the consensus that came out of the 2018 Lightning Developer Summit was to postpone updating the lightning specification to include ``payment points'' until Schnorr becomes viable.\cite{zmn-2pecdsa}

We present a workaround that allows protocol designers to realise many of the benefits of scriptless protocols in Bitcoin as it is today. To do so, we relax the scriptless model slightly to what we call the ``semi-scriptless'' model where protocols are allowed to use a single $\OPCHECKMULTISIG$ script opcode but no others. $\OPCHECKMULTISIG$ acts as a naive ECDSA multi-signature scheme, where the public key for the scheme is the concatenation of each party's public keys and a valid signature is the concatenation of valid signatures under each public key. When locking coins with \OPCHECKMULTISIG, a set of public keys is specified along with how many of those keys must authorize any transaction spending from it. We will only use ``2-of-2'' outputs which require two signatures on two out of two of the specified public keys.

\begin{figure}[h]
    \centering
    \begin{mdframed}
    \begin{pchstack}[center]
    \procedure{$\textsf{2p-Sign}(pk := (pk_1,pk_2), m)$}{
     \textbf{P}_1(sk_1) \< \< \textbf{P}_2(sk_2) \\
     \sigma_1 \sample \Sign(sk_1,m) \< \< \\
     \< \sendmessageright*[0.4cm]{\sigma_1} \< \\
     \< \< \Verify(pk_1,m,\sigma_1) \stackrel{?}{=} 1 \\
     \< \< \sigma_2 \sample \Sign(sk_2, m) \\
     \< \< \pcreturn \sigma := (\sigma_1,\sigma_2) \\
    }
    % \end{pchstack}
    % \begin{pchstack}[center]
    \procedure{$\textsf{2p-EncSign}(pk := (pk_1, pk_2),pk_E,m)$}{%
        \textbf{P}_1(sk_1) \< \< \textbf{P}_2(sk_2) \\
        \hatsigma_1 \sample \EncSign(sk_1,pk_E,m) \< \< \\
        \rec \gets \RecKey(pk_E, \hatsigma_1) \< \< \\
        \< \sendmessageright*[0.4cm]{\hatsigma_1} \< \\
        \< \< \EncVer(pk_1,pk_E,m,\hatsigma_1) \stackrel{?}{=} 1 \\
        \< \< \sigma_2 \sample \Sign(sk_2, m) \\
        \< \< \hatsigma := (\hatsigma_1, \sigma_2) \\
        \pcreturn \rec  \< \< \pcreturn \hatsigma
    }
    \end{pchstack}
    \end{mdframed}
    \caption{The two-party signing and encrypted signing algorithms for an 2-of-2 \OPCHECKMULTISIG output.}
    \label{opcms-2p-ves}
\end{figure}

We can transform any existing scriptless protocol into a semi-scriptless protocol by locking funds to an \OPCHECKMULTISIG 2-of-2 on two distinct public keys and using the single signer ECDSA one-time VES from Section~\ref{ecdsa-ot-ves-section}. The simple two-party signing and encrypted signing protocols are presented in Figure~\ref{opcms-2p-ves}.

The downsides of semi-scriptless protocols are readily apparent. First, the transactions are larger because they require two public keys and two signatures to spend them (in addition the overhead that comes from using script). Secondly, it is easy to distinguish \OPCHECKMULTISIG outputs from a regular payment transactions (but not from other uses of \OPCHECKMULTISIG 2-of-2).

Having said this, semi-scriptless protocols are a practical alternative to two-party ECDSA to developers who wish to attempt to realise many of the benefits of scriptless protocols prior to the Schnorr upgrade. In general, semi-scriptless enjoy better confidentiality than their script based counterparts. Although script is used, \OPCHECKMULTISIG is not particular to any protocol making it at more confidential than protocols with a unique script structure. For the following protocols we note the following particular benefits:

\begin{itemize}
    \item \textbf{Payment Channels \cite{poon2016bitcoin}:} The typical hash lock can be replaced with a discrete logarithm based lock which enables the privacy benefits from \cite{cryptoeprint:2018:472} other conjectured improvements\cite{lightning-dev-scriptless-scripts}.
    \item \textbf{Atomic swaps \cite{scriptless-atomic-swap}:} The secret that releases funds from the escrow transactions never appears on the ledger, unlike the existing hash constructions which make it easy to associate assets changing hands as the contracts on the ledgers share the same hash.
    \item \textbf{Discreet Log Contracts \cite{dryja2017discreet}:} The protocol can be completed in two transactions rather than three.
\end{itemize}

\FloatBarrier
\bibliography{bib.bib}{}
\bibliographystyle{unsrt}

\appendix
\section{ Proof for Theorem \ref{claim-ecdsa-eufcma}}

\newcommand{\Ocdh}{\mathcal{O}_{\CDH}}
\newcommand{\betarange}{\mathbb{B}}
\newcommand{\Sdleq}{\pcalgostyle{S}_{\DLEQ}}

\emph{authors note: This proof is wrong. By giving the reduction access to the
  $\Ocdh$ oracle we implicitly make the discrete logarithm problem
  easy\cite{Kushwaha16} making the reduction from the discrete logarithm
  pointless. I am in the process of fixing the proof so that it no longer
  requires such a powerful oracle and can be reduced from the discrete logarithm
  problem with a static Diffie-Hellman oracle. Technically, this is slightly easier than the
  usual discrete logarithm problem but still secure in practice.\cite{SDHP}}

\label{proof-ecdsa-eufcma}
As we have proved, the ECDSA one-time VES is not \EUFCMAVES secure if the CDH problem is hard. We now wish to show that if the CDH problem were easy then it would satisfy \EUFCMAVES i.e.\ leak no useful information to a forger. Thus we give our reduction access to an $\Ocdh$ oracle which when queried with $\Ocdh(X,Y)$ returns $Z$ such that (X,Y,Z) is a Diffie-Hellman tuple with respect to $g$. Additionally, in the reduction we simulate the NIZK $\DLEQ$ proof $\pi$ with $\Sdleq$.

As our starting point, we take the \EUFCMA reduction for ECDSA by Fersch et al.\cite{ecdsa-eufcma} to the discrete logarithm problem. In this work, the conversion function $f:\G \rightarrow \ZZ_q$ that maps a group element to its x-coordinate mod $q$ is decomposed and idealised as an oracle. The forger must query this oracle to produce a valid forgery. During the reduction, this oracle is programmable. In more detail, $f$ is decomposed as $f = \psi \circ \Pi \circ \varphi$ where:

\begin{enumerate}
    \item $\varphi$ is an invertible 2-to-1 function mapping curve points to the domain of $\Pi$ reflecting the fact that every x-coordinate belongs to two possible group elements.
    \item $\Pi$ is the bijective random oracle that the reduction is able to program.
    \item $\psi$ is an invertible function that maps the range of $\Pi$ (denoted as $\betarange$)  to $\ZZ_q$.
\end{enumerate}

We sketch the simulation of the signature encryption oracle $E$ in this model below. Note that we leave out and simplify some important details for the sake of clarity and encourage the reader to review the original proof in \cite{ecdsa-eufcma} to get a full understanding of the reduction.


\begin{center}
    \fbox{
        \begin{pchstack}
         \procedure{$\RDL(X)$}{
            Q \gets \emptyset; \Pi \gets \emptyset  \\
            \pccomment{Run the reduction from \cite{ecdsa-eufcma}} \\
            \text{...} \gets \F^{E,S}_{\EUFCMAVES}(X) \\
        }
        \procedure{Simulate $S(m)$}{
            \beta \sample \betarange \\
            \pcif (\cdot, \beta) \in \Pi: \textbf{abort} \\
            \Rx{} \gets \psi(\beta) \\
            s \sample \ZZ_q \\
            R \gets (g^{H(m)}X^{\Rx})^{s^{-1}} \\
            \alpha \gets \varphi(R) \\
            \pcif (\alpha,\cdot) \in \Pi: \textbf{abort} \\
            \Pi \gets \Pi \cup \{ (\alpha, \beta) \} \\
            Q \gets Q \cup \{m\} \\
            \pcreturn (s, \Rx)
        }
        \pchspace
        \procedure{Simulate $E(Y, m)$}{
            \beta \sample \betarange \\
            \pcif (\cdot, \beta) \in \Pi: \textbf{abort} \\
            \Rx{} \gets \psi(\beta) \\
            \hat{s} \sample \ZZ_q \\
            \hat{R} \gets (g^{H(m)}X^{\Rx})^{\hat{s}^{-1}} \\
            R \gets \Ocdh(\hat{R}, Y) \\
            \pi \gets \Sdleq((g, \hat{R}),(Y,R)) \\
            \alpha \gets \varphi(R) \\
            \pcif (\alpha,\cdot) \in \Pi: \textbf{abort} \\
            \Pi \gets \Pi \cup \{ (\alpha, \beta) \} \\
            Q \gets Q \cup \{m\} \\
            \pcreturn (R, \hat{R}, \hat{s}, \pi) \\
        }
        \end{pchstack}
    }
\end{center}

The fact that we can simulate $E$ with access to $\Ocdh$ without modifying the internals of $\RDL$ completes the proof.

% \section{Semi-Scriptless Time-Lock Protocol}

% \begin{figure}[h]
%     \centering
%     \begin{mdframed}
%     \begin{center}
%         \pseudocode{%
%         \\
%         \textbf{Alice}(Y, \addrRefund, \TxInput) \< \< \textbf{Bob}(Y,\addrRedeem) \\[0.1 \baselineskip][\hline]
%         \< \< \\[0.5\baselineskip]
%         (sk_A,pk_A) \sample \KeyGen \< \< \\
%         \< \sendmessageright*{pk_A, \TxInput, \addrRefund} \< \\
%         \< \<  (sk_B,pk_B) \sample \KeyGen \\
%         \< \< script := \texttt{OP\_CMS-2of2}(pk_A,pk_B) \\
%         \< \< \TxFund \gets \TxGen(\TxInput, script) \\
%         \< \< \TxRefund \gets \TxGen(\TxFund, \addrRefund) \\
%         \< \< \refundSig^B \sample \Sign(sk_B, \TxRefund) \\
%         \< \sendmessageleft*{pk_B, \refundSig, \addrRedeem} \< \\
%         script := \texttt{OP\_CMS-2of2}(pk_A,pk_B) \\
%         \TxFund \gets \TxGen(\TxInput, script) \< \< \\
%         \TxRefund \gets \TxGen(\TxFund, \addrRefund) \< \< \\
%         \Verify(pk_B, \TxRefund, \refundSig^{B}) \stackrel{?}{=} 1 \\
%         \refundSig^{A} \sample \Sign(sk_A, \TxRefund) \\
%         \refundSig := (\refundSig^{A},\refundSig^{B}) \\
%         \TxRedeem \gets \TxGen(\TxFund, \addrRedeem) \< \< \\
%         \redeemEncSig^A \sample \EncSign(sk_A, Y, \TxRedeem) \\
%         \rec \gets \RecKey(Y, \redeemEncSig^A) \\
%         \< \sendmessageright*{\redeemEncSig^A} \< \\
%         \< \< \TxRedeem \gets \TxGen(\TxFund, \addrRedeem) \\
%         \< \< \EncVer(pk_A, Y, \TxRedeem, \redeemEncSig^A) \stackrel{?}{=} 1 \\
%         \< \< \redeemSig^B \sample \Sign(sk_B,\TxRedeem) \\
%         \< \< \redeemEncSig := (\redeemEncSig^A, \redeemSig^B) \\
%         \pcreturn \TxFund, (\TxRefund, \refundSig), (\TxRedeem, \rec) \< \< \pcreturn \TxFund, (\TxRedeem, \redeemEncSig) \\
%     }
%     \end{center}
%     \end{mdframed}
%     \caption{Caption}
%     \label{fig:my_label}
% \end{figure}

\end{document}






% \subsection{Opacity}

% The opacity property ensures that only those who have the decryption key can extract the signature from a VES ciphertext. The definition was not orthogonal to the unforgeability of the underlying signature scheme. The adversary did not have to necessarily decrypt the ciphertext to break opacity; simply forging a totally different signature on the same message as the encrypted signature was enough to win the game. Note that the BGLS scheme has deterministic signatures so this distinction was not important. We remedy both these issues in the our new definition:

% \newcommand{\VESopacity}{\textsf{VES-Opacity}^{\adv}_{\hatSigma}}
% \begin{definition}[Opacity]
% A VES scheme $\hatSigma$ is opaque if for every PPT algorithm $\adv$, with access to a signature encryption and decryption oracle $ED$, the $\textsf{VES-Opacity}^{\adv}_{\hatSigma}$ experiment outputs 1 with at most negligible probability over the coin tosses of the oracles, $\EncGen, \KeyGen, \EncSign$ and $\adv$. Specifically, for an adversary $\adv(\pkSign,\pkEnc,m,\hatsigma)$, $ED$ responds to requests of the form $(m', \pkEnc)$ if $m' \neq m$ with $(\sigma, \hatsigma)$ such that $\EncVer(\pkSign, \pkEnc, m', \hatsigma) = 1$ and $\sigma$ is the decryption of $\hatsigma$.
% \begin{center}
%     \fbox{
%         \procedure{$\VESopacity$}{%
%             \kSign \sample \KeyGen \\
%             \kEnc \sample \EncGen \\
%             \hatsigma \sample \EncSign(\pkSign, \pkEnc, m) \\
%             \sigma \sample \adv^{E,D}(\pkSign, \pkEnc, m, \hatsigma) \\
%             \pcreturn \sigma = \DecSig(\skEnc,\hatsigma) \\
%         }
%         \pchspace
%         \procedure{Oracle $\tilde{E}_{\pkSign,\pkEnc}(m')$}{
%              \pcreturn \EncSign(\skSign,\pkEnc,m')
%         }
%         \pchspace
%         \procedure{Oracle $\tilde{D}_{\pkEnc}$}{}

%     }
% \end{center}

% \end{definition}

% It is rather straightforward to see that for a StE VES, if the encryption algorithm is at least one-way then extracting the signature without the decryption key will be hard.  First, we recall the definition of \emph{one-way under chosen plain text attack} (\textsf{OW-CPA}) secure public key encryption.

% \begin{definition}[OW-CPA]
%  An public key encryption scheme $\Pi = (\EncGen, \Enc, \Dec)$ with message space $\mathcal{M}$ is \textsf{OW-CPA} if every PPT algorithm $\adv$ the $\textsf{OW-CPA}^{\adv}_{\Pi}$ experiment outputs 1 with at most negligible probability.
%  \begin{center}
%      \fbox{
%         \procedure{$\textsf{OW-CPA}^{\adv}_{\Pi}$}{
%             \kEnc \sample \EncGen \\
%             m \sample \mathcal{M} \\
%             c \sample \Enc(\pkEnc, m) \\
%             m' \sample \adv(\pkEnc, c) \\
%             \pcreturn m' = m \\
%         }
%      }
%  \end{center}
% \end{definition}


% \begin{theorem}
% Let $\hatSigma$ be StE VES scheme with associated public key encryption scheme $\Pi$ and let $\Sigma$ be its underlying signature scheme. If $\Sigma$ is \EUFCMA and $\Pi$ is \textsf{OW-CPA} then it is opaque.
% \end{theorem}

% \begin{proof}[Proof Sketch]
% The only ways for the adversary can output $\sigma = \DecSig(\skEnc, \hatsigma)$ and break the opacity of $\hatSigma$ in the $\VESopacity$ experiment is to (i) forge the signature or (ii) decrypt the ciphertext. Since $\Sigma$ is \EUFCMA and $\hatSigma$ is StE, it is also \EUFCMAVES which means it will succeed at (i) with negligible probability and since the encryption is \textsf{OW-CPA} it will succeed at (ii) with negligible probability.
% \end{proof}
