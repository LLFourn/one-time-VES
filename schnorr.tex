%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
\section{Schnorr One-Time VES Scheme}
What we call the Schnorr one-time VES was introduced by Poelstra \cite{poelstra2017scriptless} which he termed an ``adaptor signature''\cite{poelstra-adaptor} with the encryption key being termed an ``auxiliary point''\cite{blind-tumbler} or sometimes just ``$T$''. A major benefit of our one-time VES concept is to be able to explain this useful idea with intuitive encryption/decryption semantics. It is typically described with a two-party signing protocol as this is where it is most useful. We describe the single singer scheme in Figure~\ref{fig:schnorr-ves} including its underlying Schnorr signature scheme. The Schnorr signature scheme was introduced by its namesake in \cite{Schnorr:1989:EIS:646754.705037} and our description resembles the key-prefixed scheme described in the Schnorr Bitcoin Improvement Proposal\cite{bip-schnorr} currently under consideration.

\begin{figure}[h]

    \centering
    \begin{mdframed}
    \begin{pchstack}[center]
    \procedure{$\KeyGen/\EncGen$}{
        x \sample \ZZ_q; X \gets g^{x} \\
        sk := (x,X); pk := X \\
        \pcreturn (sk,pk)
    }
    \pchspace
    \procedure{$\Sign(\skSign, m)$}{
        (x,X) := \skSign; \\
        r \sample \ZZ_q; R \gets g^r \\
        c := H(R || X || m) \\
        s \gets r + cx \\
        \pcreturn \sigma := (R,s) \\
    }

    \procedure{$\Verify(\pkSign,m,\sigma)$}{
        X := \pkSign; (R,s) := \sigma \\
        c := H(R || X || m) \\
        \pcreturn R = g^{s}X^{-c}
    }
    \pchspace
    \procedure{$\EncSign(\skSign,\pkEnc, m)$}{%
        (x,X) := \skSign; Y := \pkEnc  \\
        r \sample \ZZ_q; \hat{R} \gets{} g^r \\
        R \gets \hat{R}Y \\
         c := H(R || X || m) \\
        \hat{s} \gets r + cx \\
         \pcreturn \hat{\sigma} := (\hat{R},\hat{s}) \\
    }
    \end{pchstack}
    \begin{pchstack}[center]
    \procedure{$\EncVer(\pkSign,\pkEnc, m, \hatsigma)$}{%
        X := \pkSign; Y := \pkEnc \\
        (\hat{R},\hat{s}) := \hatsigma \\
        R \gets \hat{R}Y \\
        c := H(R || X || m) \\
        \pcreturn \hat{R} = g^{\hat{s}}X^{-c} \\
    }
    \pchspace
    \procedure{$\DecSig(\skEnc,\hatsigma)$}{
        (\hat{R},\hat{s}) := \hatsigma \\
        (y, Y) := \skEnc \\
        R \gets \hat{R}Y \\
        s \gets \hat{s} + y \\
        \pcreturn \sigma := (R,s)
    }
    \pchspace
    \procedure{$\RecKey(\pkEnc, \hatsigma)$}{
        (\hat{R},\hat{s}) := \hatsigma \\
        \pcreturn \rec := \hat{s} \\
    }
    \pchspace
    \procedure{$\Rec(\sigma, \rec)$}{
        (R,s) := \sigma \\
        \hat{s} := \rec \\
        y \gets  s - \hat{s} \\
        \pcreturn y
    }
    \end{pchstack}
    \end{mdframed}
    \caption{The algorithms of the Schnorr one-time VES scheme with a hash algorithm $H$}
    \label{fig:schnorr-ves}
\end{figure}

Since the $\EncSign$ algorithm is a simple tweak of the sign algorithm it is easy to get an intuition for the security of the scheme.
Unsurprisingly, we find that the scheme is unconditionally valid and recoverable and is $\EUFCMAVES$ secure.
We now formally prove these properties.

\begin{lemma}
The Schnorr one-time VES is unconditionally valid and recoverable.
\end{lemma}

\begin{proof}
 Since $\EncVer(X,Y,m,(\hat{R},\hat{s})) = 1$ implies $ \hat{R} = g^{\hat{s}}X^{-c}$ where $c := H(\hat{R}Y || X || m)$, by the one-way homomorphism between $\ZZ_q$ and $\G$ we know that $\hatsigma$ encrypts some valid signature $(R,s) := (\hat{R}Y, \hat{s} + y)$ where $g^y = Y$ and is therefore valid because:
\[ \hat{R}Y = Yg^{\hat{s}}X^{-c} = g^{\hat{s} + y}X^{-c} \]
By the same token, the scheme is recoverable because $\Rec((\hat{R}Y, \hat{s} + y)), \hat{s})$ always returns the decryption key $y = s - \hat{s}$.
\end{proof}

To prove $\EUFCMAVES$ security we start with an existing $\EUFCMA$ reduction and apply the simulator substitution lemma to preserve the reduction against adversaries with access an encrypted signature oracle instead.
Pointcheval and Stern\cite{pointcheval2000security} provided the original ``forking lemma'' $\EUFCMA$ security proof for Schnorr signatures that reduced from $\DLOG$ to its $\EUFKO$ security which they then reduced to its $\EUFCMA$ security.
The simulator for $S$ used in the proof below is the black-box version of the simulation in the original reduction.

\begin{theorem}

  Let $\R$ be a reduction to the $\EUFCMA$ security of the Schnorr signature scheme in the random oracle model which uses the signature simulator $\Sim_S$ as below.
  If $\R$ shows that the Schnorr signature scheme is at least $(\tau,\e,Q_S,Q_H)$-$\EUFCMA$ secure then the Schnorr one-time VES is at least $(\tau',\e,Q_E,Q_H)$-$\EUFCMAVES$ secure where

  \[ Q_E = Q_S, \tau = \tau' +  et_\G \]

  \hfill \break and $t_{\G}$ is the time for a group operation and $e$ is the number of times $\R$ executes $\Sim_S$.
\end{theorem}


\begin{proof}

  In the random oracle model, the Schnorr signature oracle $S$ (for $\EUFCMA$) and encrypted signature oracle $E$ (for $\EUFCMAVES$) can be simulated by the algorithms $\Sim_S$ and  $\Sim_E$ respectively.
  $\Sim_S$ is an adapted version of the original simulator which does not program the random oracle or abort itself but rather returns how the random oracle should be programmed in its returned advice $\radvice := ((R,X,m),c)$ and lets the reduction decide whether to abort.
  $\Sim_E$ uses the same approach to simulate encrypted signatures.
  It is clear to see that the distribution of $\rquery$ for both reductions is the same as in the real experiments.

  \begin{center}
  \fbox{%
    \procedure{$\Sim_S(\pkSign := \advice, (m) := \query_S)$}{
            X := \pkSign \\
            s,c \sample \ZZ_q^2 \\
            R \gets g^sX^{-c} \\
            \radvice := ((R,X,m),c) \\
            \rquery := (R,s) \\
            \pcreturn (\radvice, \rquery)
        }
        \pchspace
        \procedure{$\Sim_E(\pkSign := \advice, (\pkEnc,m) := \query_E)$}{
             X := \pkSign; Y := \pkEnc \\
             \hat{s},c \sample \ZZ_q^2 \\
             \hat{R} \gets g^{\hat{s}}X^{-c} \\
             R \gets \hat{R}Y \\
             \radvice := ((R,X,m), c)\}  \\
             \rquery := (\hat{R},\hat{s}) \\
             \pcreturn (\radvice, \rquery)
        }
    }
  \end{center}

  These two oracle simulators are substitutable as per Lemma~\ref{oracle-sub} which requires that for all possible $(\advice, \query_E)$ there must a $\query_S$ such that $\radvice$ is distributed identically between them.
  This is clearly the case here since for any value of $\query_S$ will produce $\radvice := ((R,X,m), c)$ will the same distribution as any $\query_E$ for any $\advice$.
  Clearly $\Sim_E$ runs in the same time as $\Sim_S$ except for one extra group operation so the substitution means the reduction loses $et_{\G}$ time.
\end{proof}

Note that for the typical reduction\cite{pointcheval2000security} from the $\EUFKO$ security of Schnorr $e = Q_S$.
