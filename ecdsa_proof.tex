%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:

\section{ Proof for Theorem \ref{claim-ecdsa-eufcma}}
\label{proof-ecdsa-eufcma}
\newcommand{\psidomain}{\mathbb{B}}
\newcommand{\phirange}{\mathbb{A}}
\newcommand{\Sdleq}{\mathcal{S}_{\DLEQ}}
\newcommand{\B}{\mathcal{B}}

First, we give more thorough description of the original $\EUFCMA$ reduction by Fersh et al.\cite{ecdsa-eufcma}.
Fersh et al.\ decompose and idealize the conversion function $f:\G \rightarrow \ZZ_q$ that maps a group element to its x-coordinate mod $q$ as a random oracle.
The forger queries the bijective random oracle $\Pi$ and the signature oracle $S$ and eventually outputs an ECDSA forgery with some probability.
The reduction programs the oracle and rewinds the successful forger in an attempt to get it to produce two signatures with different values for $\Rx = f(R)$ but the same value for $R$ in the typical ``forking lemma'' style\cite{pointcheval2000security}.
In more detail, $f$ is decomposed as $f = \psi \circ \Pi \circ \varphi$ where:

\begin{enumerate}
    \item $\varphi: \G \rightarrow \phirange$ is an invertible 2-to-1 function mapping curve points to the domain of $\Pi$ reflecting the fact that every x-coordinate belongs to two possible group elements.
    \item $\Pi: \phirange \rightarrow \psidomain$ is the bijective random oracle that the reduction is able to program.
    \item $\psi: \psidomain \rightarrow \ZZ_q$ is a ``semi-injective'' invertible function that maps the range of $\Pi$ to $\ZZ_q$.
\end{enumerate}

Fersh et al.\ split up their security proof by first doing a reduction from the ECDSA's $\EUFKO$ security to $\EUFCMA$ and then from $\DLOG$ to $\EUFKO$.
To make our security claim we imagine that these two reductions have been combined into one so that $\DLOG$ is reduced directly to $\EUFCMA$ and then tranform that reduction by replacing $S$ with $E$.


\begin{proof}


  In the bijective random oracle model, the ECDSA signature oracle $S$ (for $\EUFCMA$) and encrypted signature oracle $E$ (for $\EUFCMAVES$) can be simulated by the algorithms $(\Sim_S, \Sim_E)$ below.
  $\Sim_S$ is adapted from the original simulator from Fersh et al.\cite{ecdsa-eufcma} (Figure 5).
  Unlike the original, $\Sim_S$ does not program the oracle responses directly but returns them as advice $\radvice := ((\alpha, \beta),m)$ along with the message.
  It returns the message because the reduction needs extract a hash collision from an adversary that forges a signature by querying $m$ to $\Sim_S$ and finding $H(m') = H(m)$.


  To simulate $E$, for a query $(Y,m)$ $\Sim_E$ must return a valid tuple $(R,\hat{R}, \hat{s}, \pi)$ with respect to a programmed entry $(\alpha, \beta) \in \Pi$.
  We sample $\beta$ and $\hat{s}$ randomly as in the $\Sim_S$.
  The difficult part is to return $(\hat{R}, R)$ such that $\hat{R}^y = R$ where $Y = g^y$ since the simulator does not know $y$.
  The trick is achieve this shown in lines 7-11 of Figure~\ref{sim-ecdsa}.
  First we query $\OSDH$ with $Y$ to learn $Z = Y^x = X^y$ and then use the fact that $(Y,Z) = (g,X)^y$ to compute $R = \hat{R}^y$.
  Once we have a well formed $(\hat{R}, R)$ we run the zero-knowledge simulator for $\Pdleq$ which we denote $\Sdleq$ to create $\pi$.
  To complete the simulation we program our return advice $\radvice$ with $\beta$ and $\alpha \gets \varphi(R)$.
  $(R,\hat{R}, \hat{s}, \pi)$ is a valid and uniformly distributed ECDSA encrypted signature with $\Pi$ programmed with $(\alpha, \beta)$, and therefore $\Sim_E$ simulates $E$.

\begin{figure}[h]
    \centering
    \begin{mdframed}
    \begin{pchstack}[center]
      \procedure{$\Sim_S(\pkSign := \advice, (m) := \query_S)$}{
        X := \pkSign \\
        \beta \sample \psidomain \\
        \Rx{} \gets \psi{}(\beta) \\
        \pcif \Rx = 0 \pcthen \pcreturn \bot \\
        s \sample \ZZ_q \\
        \pcif s = 0 \pcthen \pcreturn \bot \\
        u_1 \gets H(m)s^{-1} \\
        u_2 \gets \Rx{}s^{-1} \\
        R \gets g^{u_1}X^{u_2} \\
        \pcif R = 1 \pcthen \pcreturn \bot \\
        \alpha \gets \varphi(R) \\
        \rquery_S := (\Rx, s) \\
        \radvice_S := ((\alpha,\beta), m) \\
        \pcreturn (\radvice_S, \rquery)
      }
      \pchspace
      \procedure[linenumbering]{$\Sim_E(\pkSign := \advice, (\pkEnc,m) := \query_E)$}{
        X := \pkSign; Y := \pkEnc \\
        \beta \sample \psidomain \\
        \Rx{} \gets \psi(\beta) \\
        \pcif \Rx = 0 \pcthen \pcreturn \bot \\
        \hat{s} \sample \ZZ_q \\
        \pcif \hat{s} = 0 \pcthen \pcreturn \bot \\
        Z \gets \OSDH(Y) \\
        u_1 \gets H(m)\hat{s}^{-1} \\
        u_2 \gets \Rx{}\hat{s}^{-1} \\
        \hat{R} \gets X^{u_1}g^{u_2} \\
        R \gets Z^{u_1}Y^{u_2} \\
        \pcif R = 1 \pcthen \pcreturn \bot \\
        \pi \gets \Sdleq((g, \hat{R}),(Y,R)) \\
        \alpha \gets \varphi(R) \\
        \rquery_E := (R, \hat{R}, \hat{s}, \pi) \\
        \radvice_E := ((\alpha,\beta), m) \\
        \pcreturn (\radvice_E, \rquery)
      }
    \end{pchstack}
    \end{mdframed}
    \caption{The original simulator for the signing oracle $S$ with our simulator for $E$.}
    \label{sim-ecdsa}
  \end{figure}


  Now we argue that these two simulators are substitutable as per Lemma~\ref{oracle-sub} which requires that for all $\advice$ and all $\query_E$ there must exists a $\query_S$ such that $\radvice_E$ and $\radvice_S$ are distributed identically.
  For every $\query_E := (Y, m)$ there is obviously the query $\query_S := (m)$ which means the $m$ in  $\radvice_S$ and $\radvice_E$ will be the same.
  So we require that for all $X$, and all values of $(Y,m)$ the distributions of $(\alpha_E,\beta_E)$ and $(\alpha_S,\beta_S)$ are identical where

  \begin{align*}
    & (((\alpha_E,\beta_E), m), \cdot) \sample \Sim_E(X,(Y,m)) \\
    & (((\alpha_S,\beta_S), m), \cdot) \sample \Sim_S(X,(m))
  \end{align*}

  $\beta_E$ and $\beta_S$ are sampled uniformly in both cases.
  Although $R$ is computed differently it is distributed identically and so $\alpha_S \gets \varphi(R)$ and $\alpha_E \gets \varphi(R)$ are also distributed the same.
  Thus the oracle simulators $S_S$ and $S_E$ are substitutable.

  As proved in Lemma~\ref{oracle-sub}, since we provide $\Sim_E$ with an additional oracle $\OSDH$ the reduction bounds adversaries against $\EUFCMAVES$ against the hardness of $u\QDLSDH$ rather than ordinary $\DLOG$ (but with the same advantage bound $\bound_\e$).
  $\Sim_E$ queries $\OSDH$ once per query so $u = Q_E$.
  Since $\Sim_E$ does a extra double scalar multiplication over $\Sim_S$ we write $\tau'' = \bound_\tau(\tau_{\sdh},Q_E, Q_{\Pi}) -  2et_{\G^*}$.

\end{proof}

\section{Hardness of $u\QDLSDH$ in secp256k1}
\label{secp-qdlsdh}

We base our estimates on the work of Brown et al.\cite{SDHP} who show approximately the best known algorithm for solving $u\QDLSDH$\footnote{In our description of $u\QDLSDH$ the adversary is given a challenge group element up front (to make it easy to apply the simulator substitution lemma) and in Brown et al.\ work they only provide the oracle but this difference is immaterial.} which works in $O(\sqrt{q/u})$ time where $q$ is the order of the group.
The intuition for the algorithms is this: if we suppose the order of $Z^*_q$ is divisible by $u$ and so $uv = q-1$ for some $v$, then there are subgroups of $Z^*_q$ of order $u$ and $v$ since they both divide the order.
Simplifying a bit, the attack splits the problem of finding the discrete logarithm $x$ into finding the discrete logarithm of two smaller components of $x$ in the subgroups of order $u$ and $v$.
To this end the attacker queries the oracle $u$ times to compute $g^{x^u}$ which allows it to work in the subgroup of order $v$ where it solves the smaller $\DLOG$ problem using a modified baby-step-giant-step algorithm.
With that result, they are able to do the same for the subgroup of order $u$ and combine the two results to finally output the discrete logarithm.

In addition to $u$ oracle queries the algorithm requires $n = 2(\sqrt{u} + \sqrt{v})$ scalar multiplications in $\G$ to finally output the discrete logarithm with certainty.
Treating the oracle queries and scalar multiplications as equal, the algorithm has an optima running time of approximately $3\sqrt[3]{q}$ whenever $u = \sqrt[3]{q}$.
We provide concrete estimates for the amount of computation needed to run this algorithm on secp256k1 in Figure~\ref{fig:sdh_alg_time}.
As expected, the table shows the optimal value for $u$ (treating scalar multiplications between the attacker and the oracle as equal) is $~2^{84} \approx \sqrt[3]{q}$ which gives $n \approx ~2^{86}$.
Smaller and more plausible values for $u$, e.g. $u \approx 2^{24} \approx$ 16 million give $n \approx 2^{116}$ which means receiving 16 million encrypted signatures of your choosing will only improve your ability to solve the discrete logarithms over the generic algorithms which take $O(\sqrt{q}) \approx 2^{128}$ group operations.

\begin{figure}[h]
  \centering
  \[ q = 2^6 \times 3 \times 149 \times 631 \times 107361 793816 595537 \times 174 723607 534414 371449 \times 341 948486 974166 000522 343609 283189  \]
 \begin{tabular}{||c c c c||}
 \hline
 $\geq \log_2u $ & $\floor{\log_2u}$ & $\floor{\log_2n}$ & Factorization of $u$ \\ [0.5ex]
 \hline\hline
  * & 84 & 86 & $2 \times 149 \times 631 \times 174723607534414371449$ \\
  \hline
  80 & 80 & 88 & $2^2 \times 3 \times 631 \times 174723607534414371449$ \\
  \hline
  70 & 70 & 93 & $2^3 \times 174723607534414371449$ \\
  \hline
  60 & 60 & 98 & $2^2 \times 3 \times 107361793816595537$ \\
  \hline
  50 & 24 & 116 & $2^6 \times 3 \times 149 \times 631$ \\ [1ex]
  \hline
 \hline
\end{tabular}
\caption{The optimal number of scalar multiplications $n$ required in secp256k1 for each upper bound on the bit length of $u$ static Diffie-Hellman oracle queries to solve the $u\QDLSDH$ problem}
\label{fig:sdh_alg_time}
\end{figure}
