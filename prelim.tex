%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
\section{Preliminaries}

\subsection{Bitcoin}
We assume a fair amount of familiarity with the Bitcoin transaction structure in Section~\ref{semi-scriptless}. A Bitcoin transaction has the following elements:
\begin{itemize}
    \item A set of inputs, each of which refer to a previous output.
    \item For each input, a witness that satisfies the spending constraints specified in the output it references.
    \item For each input, a \emph{relative} time-lock which prevents the transaction from being included in the ledger until enough time has passed since the output it references was included in the ledger.
    \item A set of new outputs, each with a value and spending constraint.
    \item An \emph{absolute} time-lock, which prevents the transaction from being included in the ledger until a specific time.
\end{itemize}
Whenever a transaction is included in the ledger, its outputs are considered ``spent'' and their value is transferred to the new outputs created by the transaction (and a small fee to the miner who included them).

When we refer to a ``layer-2'' protocol we mean any protocol that is composed of messages sent between the participants and transactions sent to the ledger. A scriptless protocol means any protocol where the transactions only use a basic public key spending constraint which can only be satisfied by a signature on the spending transaction under that public key. It's important to note that a scriptless protocol can still use the time-lock constraints (and most do).

\subsection{Notation}

We reason about the security of the schemes concretely.
That is we prove that no adversary can break a scheme in \textit{less} than some time $\tau$ and with a \textit{greater} probablitly than some probablitly $\e$.
Usually we implicitly assume that each concrete instance of a scheme has been generated by some $\textsf{Setup}(1^k)$ algorihtm given a security paramter $k$.

\subsection{The Discrete Logarithm Problem}

The concrete signature schemes we deal with (Schnorr and ECDSA) are based on the discrete logarithm problem (\DLOG).
Written multiplicatively, the $\DLOG$ problem is to find $x \in \ZZ_q$ given $(X,g) \in \G^{2}$ such that $g^x = X$, in a group $\G$ of prime order $q$.
We say the $\DLOG$ problem is $(\tau,\e)$-hard in $\G$ if no adversary running in time $\tau$ can output $x$ given $(X,g)$ with probablitly greater than $\e$.

\subsection{Signature Schemes}

\begin{definition}
  \label{signature_scheme}

  A signature scheme $\Sigma$ is made up of three algorithms $(\SIGNALG)$:

  \begin{itemize}
  \item $\KeyGen \rightsample (\skSign, pkSign)$: A signing key-pair generation algorithm, which randomly generates a secret signing key $\skSign$ and a public verification key $\pkSign$.
  \item $\Sign(\skSign, m) \rightarrow \sigma$: A possibly probabilistic signing algorithm that when given a message and the secret signing key $\skSign$ returns a signature $\sigma$.
  \item $\Verify(\pkSign, m, \sigma) \rightarrow \bin$: A deterministic signature verification algorithm that outputs 1 only if the signature $\sigma$ is valid against the public signature verification key $\pkSign$.
  \end{itemize}

\end{definition}

\begin{definition}[$\EUFCMA$]
  \label{EUFCMA}
    A signature scheme $\Sigma$ is $(\epsilon, \tau, Q_S)$-$\EUFCMA$ secure if $\prob{ \EUFCMA_{\Sigma} = 1} \leq \epsilon$ for all forgers $\F$ making at most $Q_S$ signature oracle queries and running in at most time $\tau$.
\begin{center}
\fbox{
    \procedure{$\EUFCMA_{\Sigma}$}{
        Q := \emptyset \\
        (\skSign,\pkSign) \sample \KeyGen \\
        (m^*, \sigma) \sample \F^{E}(\pkSign) \\
        \pcreturn \Verify(\pkSign, m^*, \sigma) \land m^* \notin Q \\
    }
    \pchspace
    \procedure{Oracle $S(m)$}{
        Q := Q \cup \{m\}\\
        \pcreturn \Sign(\skSign,\pkEnc,m) \\
    }
}
\end{center}

\end{definition}


\subsection{Oracle Simulator Substitution}


Our main security notion for VES schemes is $\EUFCMAVES$ which is simply $\EUFCMA$ except the signature oracle $S$ is replaced with a signature encryption oracle $E$ (defined in the next section).
Clearly, $S$ can be built with $E$ by requesting a signature encryption under a known key, decrypting it and returning the result.
Unfortunately, this means that $E$ is a more powerful oracle than $S$ proving something is $\EUFCMA$ secure does not imply the scheme is $\EUFCMAVES$ secure.

It would be cumbersome to recall and manually transform existing $\EUFCMA$ proofs into $\EUFCMAVES$ proofs or to invent new reductions.
To avoid this, we formally state the rules under which we may substitute the oracle offered in a security game \emph{with a more powerful oracle} while preserving the original security proofs for the new setting.

To achieve this we will slightly violate the black-box nature of the existing reduction so we can separate them into two algorithms:
(i) the \emph{core reduction} which communicates with its challenger and uses an adversary $\adv$ to solve the challenge and the
(ii) the \emph{oracle simulators} which answer $\adv$'s queries during the reduction.

Our goal is to be able to replace an oracle simualtor, for example the simualtor for $S$ in a $\EUFCMA$ reduction with a new simualtor for $E$ without changing the core reduction.
To do this we restrict how the core reduction and the oracle simulator communicate.
Whenever $\adv$ makes a query to an oracle available to it in the security game, $\R$ answers the query by forwarding it to the simulator $\Sim$ for the oracle along with some advice $\advice$.
$\Sim$ then generates a response to the query and returns additional advice $\radvice$ to the oracle.
The response is forwarded to $\adv$.
Crucially, we do not let $\R$ read the query or the response so $\R$ cannot trivially determine which oracle $\adv$ is actually interacting with.

This separation allows us to replace an oracle simualtor for $S$ with one for $E$ without the core reduction $\R$ noticing as long as some requirements are met.
In particular, the new simulator must \emph{preserve the view of the reduction} such that when it comes time for $\R$ to extract its solution from its transcript it is not possible that it succeeds with the original simualtor but fails with the new simulator. We now formalize this requirement.

\begin{lemma}[Oracle Simualtor Substitution]
\label{oracle-sub}

Let $\hardproblem^{A}$ be a security game where the adversary has access to an oracle $A$ which allows up to $Q$ queries.
Let $\R^{A}$ be a reduction from $\ghardproblem$ to $\hardproblem^{A}$ composed of a core reduction $\R$ and a simulator $\Sim_{A}$ for $A$.
Let $\R^{B}$ be $\R$ composed with another simulator $\Sim_{B}$ for another oracle $B$.
If for all advice $\advice$ and every valid query $q_{B}$ to $B$ there is exists a query $q_{A}^*$ to $A$ such that the distributions of $\radvice_{A}$ and $\radvice_{B}$ are identical where

\[ (\radvice_A, \cdot) \sample \Sim_A(\advice, q^A) , (\radvice_B, \cdot) \sample \Sim_B(\advice, q^B) \]

Then, $R^{B}$ is a valid reduction from $\ghardproblem$ to $\hardproblem^{B}$ with not security loss but a time loss of $e(t^{B}_{\max} - t^{A}_{\min})$ where $e$ is the number of times $\R$ invokes the oracle simulator.
\end{lemma}

\begin{proof}

  Accounting for the (possibly negative) time loss is straightforward.
  Replacing $\Sim_{A}$ with $\Sim_{B}$ comes at a cost of the maximum overhead $\Sim_{B}$ has over $\Sim_{A}$ multiplied by the number of executions.

  We now show there is security loss to the substitution i.e. the advantage of $\R$ against $\ghardproblem$ does not change between executions where it is composed as $\R^{A}$ or $\R^{B}$ relative to an adversary with the same advantage.
  First note that the view of $\R$ at the end of an execution either as $\R^{A}$ or $\R^{B}$ will be in the form of:
  \[ \varGamma = (\varGamma_{\hardproblem},\varGamma_{\ghardproblem}, \varGamma_{\Sim}) \]
  where $\varGamma_{\hardproblem}$ is its transcript with $\adv$, $\varGamma_{\ghardproblem}$ is its transcript with its challenger and $\varGamma_{\Sim}$ is its transcript with the oracle simulator in the form $\varGamma_{\Sim} = (\advice_1,\radvice_1), \dots, (\advice_e,\radvice_e)$ for each of the $e$ simulated responses.

  To prove our claim, it is sufficient to show that for every adversary $\adv^{B}$ against $\R^{B}$ there exists an adversary $\adv^{A}$ against $\R^{A}$ with the same advantage and where distribution of $\varGamma$ is the same across both cases.
  If replacing $\Sim_{A}$ with $\Sim_{B}$ produces an identical transcript $\varGamma$ then $\R$ cannot extract a solution to $\ghardproblem$ with different probabilities in each case since then we could then use $\R$ as an algorithm to distinguish between identical distributions (which is a contradiction).
  Note that $\adv^{A}$ need not be efficient since distinguishing identical distributions is impossible even for an unbounded algorithm.

  We construct an inefficient $\adv^{A}$ as follows:
  $\adv^{A}$ runs $\adv^{B}$ internally and forwards all messages between the challenger and itself except for $\adv^{B}$'s queries to $B$ (note $\R^{A}$ is $\adv^{A}$'s challenger).
  Any query $\adv^{B}$ makes to $B$, $\adv^{A}$ answers by exhaustive search and then sends the distribution preserving transformation of the query $q_{A}^{*}$ to $A$ (the existence of $q_{A}^{*}$ required by the lemma).

  To show that the view of $\R$ is the same both cases we show that all messages it receives in its transcripts are distributed identically.
  By implication any message it sends will be distributed identically since it is the same core reduction generating the messages in both cases.

  First note that the messages received in $\varGamma_{\ghardproblem}$ are distributed identically since the challenger for $\ghardproblem$ is the same in both cases.
  Secondly we claim that messages from $\adv^{A}$ and $\adv^{B}$ in $\varGamma_{\hardproblem}$ have the same distribution since $\adv^{A}$ is just forwarding messages from $\adv^{B}$.
  Recall that $\adv^{A}$ simulates the responses from $B$ with an identical distribution so $\adv^{B}$'s view is the same in both cases and so its messages will distributed the same in both cases.
  Finally, the advice that is returned from $\Sim_{A}$ or $\Sim_{B}$ are distributed identically since $\adv^{A}$ translates any query destined for $\Sim_{B}$ into a query $q_{A}^{*}$ to $\Sim_{A}$ which produces $\radvice$ which is identically distributed.
\end{proof}
